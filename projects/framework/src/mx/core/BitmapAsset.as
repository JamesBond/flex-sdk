////////////////////////////////////////////////////////////////////////////////
//
//  ADOBE SYSTEMS INCORPORATED
//  Copyright 2005-2007 Adobe Systems Incorporated
//  All Rights Reserved.
//
//  NOTICE: Adobe permits you to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
//
////////////////////////////////////////////////////////////////////////////////

package mx.core
{

import flash.display.BitmapData;
import flash.display.DisplayObjectContainer;
import flash.events.Event;
import flash.geom.Matrix;

/**
 *  BitmapAsset is a subclass of the flash.display.Bitmap class
 *  which represents bitmap images that you embed in a Flex application.
 *  It implements the IFlexDisplayObject interface, which makes it
 *  possible for an embedded bitmap image to be displayed in an Image control,
 *  or to be used as a container background or a component skin.
 *
 *  <p>The bitmap image that you're embedding can be in a JPEG, GIF,
 *  or PNG file.
 *  You can also embed a bitmap symbol that is in a SWF file produced
 *  by Flash.
 *  In each of these cases, the MXML compiler autogenerates a class
 *  that extends BitmapAsset to represent the embedded bitmap image.</p>
 *
 *  <p>You don't generally have to use the BitmapAsset class directly
 *  when you write a Flex application.
 *  For example, you can embed a GIF file and display the image
 *  in an Image control by writing the gollowing:</p>
 *
 *  <pre>
 *  &lt;mx:Image id="logo" source="&#64;Embed(source='Logo.gif')"/&gt;</pre>
 *
 *  <p>or use it as the application's background image in CSS syntax
 *  by writing</p>
 *
 *  <pre>
 *  &lt;fx:Style&gt;
 *      &#64;namespace mx "library://ns.adobe.com/flex/mx"
 *      mx|Application {
 *          backgroundImage: Embed(source="Logo.gif")
 *      }
 *  &lt;fx:Style/&gt;</pre>
 *
 *  <p>without having to understand that the MXML compiler has created
 *  a subclass of BitmapAsset for you.</p>
 *
 *  <p>However, it may be useful to understand what is happening
 *  at the ActionScript level.
 *  To embed a bitmap image in ActionScript, you declare a variable
 *  of type Class, and put <code>[Embed]</code> metadata on it.
 *  For example, you embed a GIF file like this:</p>
 *
 *  <pre>
 *  [Bindable]
 *  [Embed(source="Logo.gif")]
 *  private var logoClass:Class;</pre>
 *
 *  <p>The MXML compiler sees the .gif extension, transcodes the GIF data
 *  into the bitmap format that the player uses, autogenerates
 *  a subclass of the BitmapAsset class, and sets your variable
 *  to be a reference to this autogenerated class.
 *  You can then use this class reference to create instances of the
 *  BitmapAsset using the <code>new</code> operator, and you can use
 *  APIs of the BitmapAsset class on them:</p>
 *
 *  <pre>
 *  var logo:BitmapAsset = BitmapAsset(new logoClass());
 *  logo.bitmapData.noise(4);</pre>
 *
 *  <p>However, you rarely need to create BitmapAsset instances yourself
 *  because image-related properties and styles can simply be set to an
 *  image-producing class, and components will create image instances
 *  as necessary.
 *  For example, to display this image in an Image control, you can 
 *  set the Image's <code>source</code> property to <code>logoClass</code>.
 *  In MXML you could do this as follows:</p>
 *
 *  <pre>
 *  &lt;mx:Image id="logo" source="{logoClass}"/&gt;</pre>
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 */
public class BitmapAsset extends FlexBitmap
                         implements IFlexAsset, IFlexDisplayObject, ILayoutDirectionElement
{
    include "../core/Version.as";

    //--------------------------------------------------------------------------
    //
    //  Constructor
    //
    //--------------------------------------------------------------------------

    /**
     *  Constructor.
     *
     *  @param bitmapData The data for the bitmap image. 
     *
     *  @param pixelSnapping Whether or not the bitmap is snapped
     *  to the nearest pixel.
     *
     *  @param smoothing Whether or not the bitmap is smoothed when scaled. 
     *  
     *  @langversion 3.0
     *  @playerversion Flash 9
     *  @playerversion AIR 1.1
     *  @productversion Flex 3
     */
    public function BitmapAsset(bitmapData:BitmapData = null,
                                pixelSnapping:String = "auto",
                                smoothing:Boolean = false)
    {
        super(bitmapData, pixelSnapping, smoothing);
        
        if (FlexVersion.compatibilityVersion >= FlexVersion.VERSION_4_0)
            this.addEventListener(Event.ADDED, addedHandler);
    }

    //--------------------------------------------------------------------------
    //
    //  Variables
    //
    //--------------------------------------------------------------------------
    
    private var mirror:Boolean = false;
    private var origMatrix:Matrix;
    
    //--------------------------------------------------------------------------
    //
    //  Overridden Properties
    //
    //--------------------------------------------------------------------------
    
    //----------------------------------
    //  x
    //----------------------------------
    
    private var _x:Number = 0;
    
    /**
     *  @private
     *  In the mirroring case, we restore the old transform matrix,
     *  call the superclass' setter to recalculate the transform matrix,
     *  and call validateTransformMatrix to de-mirror the matrix.
     *  This ensures that the right matrix values are used when 
     *  de-mirroring.
     */
    override public function set x(value:Number):void
    {
        if (mirror)
        {
            transform.matrix = origMatrix;
            super.x = value;
            _x = value;
            validateTransformMatrix();
        }
        else
        {
            super.x = value;
        }
    }
    
    /**
     *  @private
     */
    override public function get x():Number
    {
        // FIXME(hmuller): by default get x returns transform.matrix.tx rounded to the nearest 20th.
        // should do the same here, if we're returning _x.
        return (mirror) ? _x : super.x;
    }
    
    //----------------------------------
    //  y
    //----------------------------------
    
    /**
     *  @private
     *  We need to make sure y is saved in our copy of the matrix
     *  along with the other properties.
     */
    override public function set y(value:Number):void
    {
        if (mirror)
        {
            transform.matrix = origMatrix;
            super.y = value;
            validateTransformMatrix();
        }
        else
        {
            super.y = value;
        }
    }
    
    //----------------------------------
    //  width
    //----------------------------------
    
    /**
     *  @private
     */
    override public function set width(value:Number):void
    {
        if (mirror)
        {
            transform.matrix = origMatrix;
            super.width = value;
            // Store new scaleX/Y since setting width may modify them
            _scaleX = super.scaleX;
            _scaleY = super.scaleY;
            validateTransformMatrix();
        }
        else
        {
            super.width = value;
        }
    }
    
    //----------------------------------
    //  height
    //----------------------------------
    
    /**
     *  @private
     *  We must override height as well because setting
     *  height will force scaleX to be positive in the transform
     *  matrix.
     */
    override public function set height(value:Number):void  
    {
        if (mirror)
        {
            transform.matrix = origMatrix;
            super.height = value;
            // Store new scaleX/Y since setting height may modify them
            _scaleX = super.scaleX;
            _scaleY = super.scaleY;
            validateTransformMatrix();
        }
        else
        {
            super.height = value;
        }
    }
    
    //----------------------------------
    //  scaleX
    //----------------------------------
    
    private var _scaleX:Number;
    
    /**
     *  @private
     */
    override public function set scaleX(value:Number):void
    {
        if (mirror)
        {
            transform.matrix = origMatrix;
            super.scaleX = value;
            _scaleX = value;
            validateTransformMatrix();
        }
        else
        {
            super.scaleX = value;
        }
    }
    
    override public function get scaleX():Number
    {
        return (mirror) ? _scaleX : super.scaleX;
    }
    
    //----------------------------------
    //  scaleY
    //----------------------------------
    
    private var _scaleY:Number;
    
    /**
     *  @private
     */
    override public function set scaleY(value:Number):void
    {
        if (mirror)
        {
            transform.matrix = origMatrix;
            super.scaleY = value;
            _scaleY = value;
            validateTransformMatrix();
        }
        else
        {
            super.scaleY = value;
        }
    }
    
    override public function get scaleY():Number
    {
        return (mirror) ? _scaleY : super.scaleY;
    }

    //--------------------------------------------------------------------------
    //
    //  Properties
    //
    //--------------------------------------------------------------------------

    //----------------------------------
    //  layoutDirection
    //----------------------------------
    
    private var _layoutDirection:String = LayoutDirection.LTR;
    
    [Inspectable(category="General", enumeration="ltr,rtl")]
    
    /**
     *  @inheritDoc
     *  
     *  @langversion 3.0
     *  @playerversion Flash 10
     *  @playerversion AIR 1.5
     *  @productversion Flex 4.1
     */
    public function get layoutDirection():String
    {
        return _layoutDirection;
    }
    
    public function set layoutDirection(value:String):void
    {
        if (value == _layoutDirection)
            return;
        
        _layoutDirection = value;
        invalidateLayoutDirection();
    }

    //----------------------------------
    //  measuredHeight
    //----------------------------------

    /**
     *  @inheritDoc
     *  
     *  @langversion 3.0
     *  @playerversion Flash 9
     *  @playerversion AIR 1.1
     *  @productversion Flex 3
     */
    public function get measuredHeight():Number
    {
        if (bitmapData)
            return bitmapData.height
        
        return 0;
    }

    //----------------------------------
    //  measuredWidth
    //----------------------------------

    /**
     *  @inheritDoc
     *  
     *  @langversion 3.0
     *  @playerversion Flash 9
     *  @playerversion AIR 1.1
     *  @productversion Flex 3
     */
    public function get measuredWidth():Number
    {
        if (bitmapData)
            return bitmapData.width;
        
        return 0;
    }

    //--------------------------------------------------------------------------
    //
    //  Methods
    //
    //--------------------------------------------------------------------------

    /**
     *  @inheritDoc
     *  
     *  @langversion 3.0
     *  @playerversion Flash 10
     *  @playerversion AIR 1.5
     *  @productversion Flex 4.1
     */
    public function invalidateLayoutDirection():void
    {
        // We check the closest parent's layoutDirection property
        // set our mirror property and update our transform matrix
        // accordingly.
        var p:DisplayObjectContainer = parent;
        
        while (p)
        {
            if (p is ILayoutDirectionElement)
            {
                // If this element's layoutDirection doesn't match its parent's, then
                // set the mirror flag.
                const oldMirror:Boolean = mirror;
                mirror = (_layoutDirection != null) &&
                    (_layoutDirection != ILayoutDirectionElement(p).layoutDirection);
                
                if (mirror != oldMirror)
                {
                    if (mirror)
                    {
                        // Set backing variables to current state
                        _scaleX = super.scaleX;
                        _scaleY = super.scaleY;
                        _x = super.x;
                        validateTransformMatrix();
                    }
                    else
                    {
                        // origMatrix has been initialized in validateTransformMatrix
                        // because we weren't matching our parent's layoutDirection before.
                        transform.matrix = origMatrix;
                    }
                }
                break;
            }
            
            p = p.parent;
        }
    }

    /**
     *  @inheritDoc
     *  
     *  @langversion 3.0
     *  @playerversion Flash 9
     *  @playerversion AIR 1.1
     *  @productversion Flex 3
     */
    public function move(x:Number, y:Number):void
    {
        this.x = x;
        this.y = y;
    }

    /**
     *  @inheritDoc
     *  
     *  @langversion 3.0
     *  @playerversion Flash 9
     *  @playerversion AIR 1.1
     *  @productversion Flex 3
     */
    public function setActualSize(newWidth:Number, newHeight:Number):void
    {
        width = newWidth;
        height = newHeight;
    }
    
    /**
     *  @private
     */
    private function addedHandler(event:Event):void
    {
        invalidateLayoutDirection();
    }
    
    /**
     *  @private
     *  Modifies the transform matrix so that this bitmap
     *  will not be mirrored if a parent is mirrored.
     */
    private function validateTransformMatrix():void
    {
        // Save copy of current matrix
        origMatrix = transform.matrix.clone();
        
        // Create new de-mirrored transform matrix
        const mirrorMatrix:Matrix = transform.matrix;
        mirrorMatrix.translate(-mirrorMatrix.tx, 0);
        mirrorMatrix.scale(-1, 1);
        mirrorMatrix.translate(_x + width, 0);
        
        transform.matrix = mirrorMatrix;
    }
}

}
