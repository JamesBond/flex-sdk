////////////////////////////////////////////////////////////////////////////////
//
//  ADOBE SYSTEMS INCORPORATED
//  Copyright 2010 Adobe Systems Incorporated
//  All Rights Reserved.
//
//  NOTICE: Adobe permits you to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
//
////////////////////////////////////////////////////////////////////////////////

package spark.formatters
{

import flash.globalization.NationalDigitsType;
import flash.globalization.NumberFormatter;
import flash.globalization.NumberParseResult;

import mx.core.mx_internal;
import mx.formatters.IFormatter;

import spark.formatters.supportClasses.NumberBase;
import spark.globalization.LastOperationStatus;

use namespace mx_internal;

/**
 *  The NumberFormatter class provides locale-sensitive formatting and
 *  parsing of numeric values. It can format <code>int</code>,
 *  <code>uint</code>, and <code>Number</code> objects.
 *
 *  <p>This class is a wrapper class around the <code>flash.globalization.
 *  NumberFormatter</code>. Therefore the locale-specific formatting
 *  is provided by the <code>flash.globalization.NumberFormatter</code>.
 *  However this NumberFormatter class can be used in MXML declartions,
 *  uses the locale style for the requested Locale ID name, and has
 *  methods and properties that are bindable.  Additionally events are
 *  generated if there is an error or warning generated by the
 *  flash.globalization class.
 *  </p><p>
 *  The flash.globalization.NumberFormatter class use the underlying
 *  operating system for the formatting functionality and
 *  to supply the locale-specific data. On some operating systems, the
 *  flash.globalization classes are unsupported, this wrapper
 *  class provides a fallback functionality in this case.
 *  </p>
 *
 *  @see flash.globalization.NumberFormatter
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4.5
 */
public class NumberFormatter extends NumberBase implements IFormatter
{
    include "../core/Version.as";

    //--------------------------------------------------------------------------
    //
    //  Class Constants
    //
    //--------------------------------------------------------------------------

    private static const NEGATIVE_NUMBER_FORMAT:String = "negativeNumberFormat";

    //--------------------------------------------------------------------------
    //
    //  Constructor
    //
    //--------------------------------------------------------------------------

    /**
     *  Constructs a new NumberFormatter object to format numbers according
     *  to the conventions of a given locale.
     *  <p>
     *  The locale for this class is supplied by the locale style.
     *  The locale style can be set in several ways:
     *  </p>
     *  <ul>
     *  <li>         *
     *  Inheriting the style from a UIComponent by calling the UIComponent's
     *  addStyleClient method.
     *  </li>
     *  <li>
     *  By using the class in an MXML declaration and inheriting the
     *  locale from the document that contains the declaration.
     *  <listing version="3.0" >
     *  &lt;fx:Declarations&gt;
     *         &lt;s:NumberFormatter id="nf" /&gt;
     *  &lt;/fx:Declarations&gt;
     *  </listing>
     *  </li>
     *  <li>
     *  By using an MXML declaration and specifying the locale value in
     *  the list of assignments.
     *  <listing version="3.0" >
     *  &lt;fx:Declarations&gt;
     *      &lt;s:NumberFormatter id="nf_French_France" locale="fr_FR" /&gt;
     *  &lt;/fx:Declarations&gt;
     *  </listing>
     *  </li>
     *  <li>
     *  Calling the setStyle method, e.g.
     *  <code>nf.setStyle("locale", "fr-FR")</code>
     *  </li>
     *  </ul>
     *  <p>
     *  If the locale style is not set by one of the above techniques,
     *  the methods of this class that depend on the locale
     *  will throw an error.
     *  </p>         *
     *
     *  @playerversion Flash 10.1
     *  @langversion 3.0
     *  @productversion Flex 4.5
     *  @productversion Flash CS5
     */
    public function NumberFormatter()
    {
        super();
    }

    //--------------------------------------------------------------------------
    //
    //  Overridden Properties
    //
    //--------------------------------------------------------------------------

    //----------------------------------
    //  actualLocaleIDName
    //----------------------------------

    [Bindable("change")]

    /**
     *  @inheritDoc
     *
     *  @see flash.globalization.NumberFormatter.actualLocaleIDName
     *  @see #NumberFormatter()
     *
     *  @playerversion Flash 10.1
     *  @langversion 3.0
     *  @productversion Flash CS5
     *  @productversion Flex 4.5
     */
    override public function get actualLocaleIDName():String
    {
        if (g11nWorkingInstance)
        {
            return (g11nWorkingInstance
                as flash.globalization.NumberFormatter).actualLocaleIDName;
        }

        if ((localeStyle === undefined) || (localeStyle === null))
        {
            fallbackLastOperationStatus
                                = LastOperationStatus.LOCALE_UNDEFINED_ERROR;
            return undefined;
        }

        fallbackLastOperationStatus = LastOperationStatus.NO_ERROR;

        return "en-US";
    }

    //--------------------------------------------------------------------------
    //
    //  Properties
    //
    //--------------------------------------------------------------------------

    //----------------------------------
    //  negativeNumberFormat
    //----------------------------------

    [Bindable("change")]
    [Inspectable(category="General", enumeration="0,1,2,3,4")]

    /**
     *  A numeric value that indicates a formatting pattern for negative
     *  numbers.
     *  This pattern defines the location of the negative symbol
     *  or parentheses in relation to the numeric portion of the
     *  formatted number.
     *
     *  <p>The following table summarizes the possible formats for
     *  negative numbers. When a negative number is formatted,
     *  the minus sign in the format is replaced with the value of
     *  the <code>negativeSymbol</code> property and the 'n' character is
     *  replaced with the formatted numeric value.</p>
     *
     *    <table class="innertable" border="0">
     *        <tr>
     *            <td>Negative number format type</td>
     *            <td>Format</td>
     *        </tr>
     *        <tr>
     *            <td>0</td>
     *            <td>(n)</td>
     *        </tr>
     *        <tr>
     *            <td>1</td>
     *            <td>-n</td>
     *        </tr>
     *        <tr>
     *            <td>2</td>
     *            <td>- n</td>
     *        </tr>
     *        <tr>
     *            <td>3</td>
     *            <td>n-</td>
     *        </tr>
     *        <tr>
     *            <td>4</td>
     *            <td>n -</td>
     *        </tr>
     *    </table>
     *
     *
     *  @default dependent on the locale and operating system.
     *
     *  @throws ArgumentError if the assigned value is not a number
     *  between 0 and 4.
     *
     *  @see #negativeSymbol
     *  @see #format()
     *
     *  @playerversion Flash 10.1
     *  @playerversion AIR 2
     *  @langversion 3.0
     *  @productversion Flex 4.5
     */
    public function get negativeNumberFormat():uint
    {
        return getBasicProperty(properties, NEGATIVE_NUMBER_FORMAT);
    }

    public function set negativeNumberFormat(value:uint):void
    {
        if (!g11nWorkingInstance)
        {
            if (4 < value)
                throw new TypeError();
        }

        setBasicProperty(properties, NEGATIVE_NUMBER_FORMAT, value);
    }

    //--------------------------------------------------------------------------
    //
    //  Overridden Methods
    //
    //--------------------------------------------------------------------------

    /**
     *  @private
     */
    override mx_internal function createWorkingInstance():void
    {
        if ((localeStyle === undefined) || (localeStyle === null))
        {
            fallbackLastOperationStatus
                                = LastOperationStatus.LOCALE_UNDEFINED_ERROR;
            g11nWorkingInstance = null;
            properties = null;
            return;
        }

        if (enforceFallback)
        {
            fallbackInstantiate();
            g11nWorkingInstance = null;
            return;
        }

        g11nWorkingInstance
                    = new flash.globalization.NumberFormatter(localeStyle);
        if (g11nWorkingInstance &&
            (g11nWorkingInstance.lastOperationStatus
                                    != LastOperationStatus.UNSUPPORTED_ERROR))
        {
            properties = g11nWorkingInstance
            propagateBasicProperties(g11nWorkingInstance);
            return;
        }

        fallbackInstantiate();
        g11nWorkingInstance = null;

        if (fallbackLastOperationStatus == LastOperationStatus.NO_ERROR)
        {
            fallbackLastOperationStatus
                                = LastOperationStatus.USING_FALLBACK_WARNING;
        }
    }

    //--------------------------------------------------------------------------
    //
    //  Methods
    //
    //--------------------------------------------------------------------------

    [Bindable("change")]

    /**
     *  Formats a number.
     *
     * <p>This function formats the number based on the property values
     *  of the formatter.
     *  If the properties are not modified after the locale style is set, the
     *  numbers are formatted according to the locale-specific conventions
     *  provided by the operating system for the locale identified
     *  by actualLocaleIDName.
     *  To customize the format, the properties
     *  can be altered to control specific aspects of formatting a number.</p>
     *
     *  <p>Very large numbers and very small magnitude numbers can be
     *  formatted with this function. However, the
     *  number of significant digits is limited to the precision provided
     *  by the Number object. Scientific notation is not supported.</p>
     *
     *    @param    value    A Number value to format.
     *    @return            A formatted number string.
     *
     *  @see NumberFormatter
     *
     *  @playerversion Flash 10.1
     *  @langversion 3.0
     *  @productversion Flex 4.5
     *  @productversion Flash CS5
     */
    public function format(value:Object):String
    {
        if (value == null)
            return null;

        const number:Number = Number(value);

        if (isNaN(number))
        {
            if (g11nWorkingInstance)
            {
                // Have g11nFormatter.lastOperationStatus property hold
                // ILLEGAL_ARGUMENT_ERROR value.
                (g11nWorkingInstance as
                    flash.globalization.NumberFormatter).fractionalDigits = -1;
            }
            else
            {
                fallbackLastOperationStatus
                = LastOperationStatus.ILLEGAL_ARGUMENT_ERROR;
            }
            return errorText;
        }

        if (g11nWorkingInstance)
        {
            const g11nFormatter:flash.globalization.NumberFormatter
                = (g11nWorkingInstance as flash.globalization.NumberFormatter);

            const retVal:String = g11nFormatter.formatNumber(number);

            return errorText && LastOperationStatus.isFatalError(
                        g11nFormatter.lastOperationStatus) ? errorText : retVal;
        }

        if ((localeStyle === undefined) || (localeStyle === null))
        {
            fallbackLastOperationStatus
                                = LastOperationStatus.LOCALE_UNDEFINED_ERROR;
            return errorText;
        }

        fallbackLastOperationStatus = LastOperationStatus.NO_ERROR;

        return number.toFixed(properties.fractionalDigits);
    }

    [Bindable("change")]

    /**
     *  Parses a string and returns a NumberParseResult object containing
     *  the parsed elements.
     *
     *  <p>The NumberParseResult object contains
     *  the value of the first number found in the input string, the
     *  starting index for the number within the string, and the index
     *  of the first character after the number in the string.</p>
     *
     *  <p>If the string does not contain a number, the value property of
     *  the NumberParseResult is set to <code>NaN</code> and the
     *  <code>startIndex</code> and <code>endIndex</code> properties are
     *  set to the hexadecimal value <code>0x7fffffff</code>.
     *  </p>
     *
     *  <p>This function uses the value of the <code>decimalSeparator</code>
     *  property to determine the portion of the number
     *  that contains fractional
     *  digits, and the <code>groupingSeparator</code> property to determine
     *  which characters are allowed within the digits of a number,
     *  and the <code>negativeNumberFormat</code> property to control
     *  how negative values are represented. </p>
     *
     *  <p>The following table identifies the result of strings parsed
     *  for the various NegativeNumberFormat values:</p>
     *    <table class="innertable" border="0">
     *        <tr>
     *            <td>NegativeNumberFormat</td>
     *            <td>Input String</td>
     *            <td>Result</td>
     *         </tr>
     *        <tr>
     *            <td>(n)</td>
     *            <td>"(123)" or "( 123 )"</td>
     *            <td>"-123"</td>
     *        </tr>
     *        <tr>
     *            <td>-n</td>
     *            <td>"-123" or "- 123"</td>
     *            <td>"-123"</td>
     *        </tr>
     *        <tr>
     *            <td>- n</td>
     *            <td>"-123" or "- 123"</td>
     *            <td>"-123"</td>
     *        </tr>
     *        <tr>
     *            <td>n-</td>
     *            <td>"123-" or "123 -"</td>
     *            <td>"-123"</td>
     *        </tr>
     *        <tr>
     *            <td>n -</td>
     *            <td>"123-" or "123 -"</td>
     *            <td>"-123"</td>
     *        </tr>
     *    </table>
     *
     *  <p>A single white space is allowed between the number and the
     *  minus sign or parenthesis.</p>
     *
     *  <p>Other properties are ignored when determining a valid number.
     *  Specifically the value of the
     *  <code>digitsType</code> property is ignored and the digits can be
     *  from any of
     *  the digit sets that are enumerated in the NationalDigitsType class.
     *  The values of the <code>groupingPattern</code>
     *  and <code>useGrouping</code> properties do not influence the
     *  parsing of the number.
     *  </p>
     *
     *  <p>If numbers are preceded or followed in the string by a
     *  plus sign '+', the plus sign is treated as
     *  a character that is not part of the number.
     *  </p>
     *
     *  <p>This function does not parse strings containing numbers
     *  in scientific notation (e.g. 1.23e40).</p>
     *
     *
     *  @example The following code parses a number from a string and
     *  retrieves the prefix and suffix:
     *  <listing version="3.0" >
     *  var nf:NumberFormatter = new NumberFormatter("fr-FR");
     *  var str:String = "1,56 m&#232;tre"
     *  var result:NumberParseResult = nf.parse(str);
     *  trace(result.value) // 1.56
     *  trace(str.substr(0,result.startIndex));                // ""
     *  trace(str.substr(result.startIndex, result.endIndex)); // "1,56"
     *  trace(str.substr(result.endIndex));                 // " m&#232;tre"
     *  </listing>
     *
     *  @param inputString The input string to parse.
     *
     *  @return A NumberParseResult object containing the numeric value
     *  and the indices for the start and end of the portion of the string
     *  that contains the number.
     *
     *  @throws TypeError if the <code>inputString</code> parameter is null.
     *
     *  @see flash.globalization.NumberParseResult
     *  @see #parseNumber()
     *  @see flash.globalization.NationalDigitsType
     *
     *  @playerversion Flash 10.1
     *  @playerversion AIR 2
     *  @langversion 3.0
     *  @productversion Flex 4.5
     */
    public function parse(inputString:String):NumberParseResult
    {
        if (g11nWorkingInstance)
        {
            return (g11nWorkingInstance
                as flash.globalization.NumberFormatter).parse(inputString);
        }

        if ((localeStyle === undefined) || (localeStyle === null))
        {
            fallbackLastOperationStatus
                                = LastOperationStatus.LOCALE_UNDEFINED_ERROR;
            return undefined;
        }

        fallbackLastOperationStatus = LastOperationStatus.NO_ERROR;

        return fallbackParse(inputString);
    }

    [Bindable("change")]

    /**
     *  Parses a string that contains only digits and optional whitespace
     *  characters and returns a Number. If the string does not begin
     *  with a number or contains characters other than whitespace that
     *  are not part of the number, then this method returns
     *  <code>NaN</code>. White space before or after
     *  the numeric digits is ignored. A white space
     *  character is a character that has a Space Separator (Zs) property
     *  in the Unicode Character Database (see http://www.unicode.org/ucd/).
     *
     *  <p>If the numeric digit is preceded or followed by a
     *  plus sign '+' it is treated as a non-whitespace character.
     *  The return value is <code>NaN</code>.
     *  </p>
     *
     *  <p>See the description of the parse function for more information
     *  about number parsing and what constitutes a valid number.
     *  </p>
     *
     *  @throws TypeError if the parseString is <code>null</code>
     *
     *  @see #parse()
     *  @see flash.globalization.NationalDigitsType
     *
     *  @playerversion Flash 10.1
     *  @playerversion AIR 2
     *  @langversion 3.0
     *  @productversion Flex 4.5
     */
    public function parseNumber(parseString:String):Number
    {
        if (g11nWorkingInstance)
        {
            return (g11nWorkingInstance
                as flash.globalization.NumberFormatter).parseNumber(parseString);
        }

        if ((localeStyle === undefined) || (localeStyle === null))
        {
            fallbackLastOperationStatus
                                = LastOperationStatus.LOCALE_UNDEFINED_ERROR;
            return undefined;
        }

        fallbackLastOperationStatus = LastOperationStatus.NO_ERROR;

        return fallbackParseNumber(parseString);
    }

    /**
     *  @copy spark.globalization.supportClasses.CollatorBase#getAvailableLocaleIDNames
     *
     *  @playerversion Flash 10.1
     *  @langversion 3.0
     *  @productversion Flash CS5
     *  @productversion Flex 4.5
     */
    static public function getAvailableLocaleIDNames():Vector.<String>
    {
        const locales:Vector.<String>
            = flash.globalization.NumberFormatter.getAvailableLocaleIDNames();

        return locales ? locales : new Vector.<String>["en-US"];
    }

    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------

    private function fallbackParse(parseString:String):NumberParseResult
    {
        return parseToNumberParseResult(parseString);
    }

    private function fallbackParseNumber(value:String):Number
    {
        const res:NumberParseResult = parseToNumberParseResult(value);

        if (!res.startIndex && (res.endIndex == value.length))
            return res.value;

        return NaN;
    }

    private function fallbackInstantiate():void
    {
        properties =
            {
                fractionalDigits: 0,
                useGrouping: false,
                groupingPattern: "3",
                digitsType: NationalDigitsType.EUROPEAN,
                decimalSeparator: ".",
                groupingSeparator: ",",
                negativeSymbol: "-",
                negativeNumberFormat: 0,
                leadingZero: true,
                trailingZeros: false
            };

        propagateBasicProperties(properties);

        fallbackLastOperationStatus = LastOperationStatus.NO_ERROR;
    }
}
}
