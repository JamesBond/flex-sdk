////////////////////////////////////////////////////////////////////////////////
//
//  ADOBE SYSTEMS INCORPORATED
//  Copyright 2009 Adobe Systems Incorporated
//  All Rights Reserved.
//
//  NOTICE: Adobe permits you to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
//
////////////////////////////////////////////////////////////////////////////////

package spark.accessibility
{

import flash.accessibility.Accessibility;
import flash.events.Event;
import flash.events.FocusEvent;
import flash.events.MouseEvent;

import org.osmf.events.TimeEvent;

import mx.accessibility.AccConst;
import mx.accessibility.AccImpl;
import mx.core.UIComponent;
import mx.core.mx_internal;
import mx.events.FlexEvent;
import mx.resources.IResourceManager;
import mx.resources.ResourceManager;

import spark.components.Button;
import spark.components.mediaClasses.VolumeBar;
import spark.components.supportClasses.ToggleButtonBase;
import spark.components.VideoPlayer;
import spark.events.SkinPartEvent;
import spark.events.VideoEvent;

use namespace mx_internal;

[ResourceBundle("components")]

/**
 *  VideoPlayerAccImpl is a subclass of AccessibilityImplementation
 *  which implements accessibility for the VideoPlayer class.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 2.0
 *  @productversion Flex 4
 */
public class VideoPlayerAccImpl extends AccImpl
{
    include "../core/Version.as";

	//--------------------------------------------------------------------------
	//
	//  Class constants
	//
	//--------------------------------------------------------------------------

    /**
     *  @private
     */
    private static const VIDEOPLAYER_PLAYPAUSEBUTTON:uint = 1;

    /**
     *  @private
     */
    private static const VIDEOPLAYER_SCRUBBAR:uint = 2

    /**
     *  @private
     */
    private static const VIDEOPLAYER_CURRENTTIMEDISPLAY:uint = 3;
    
    /**
     *  @private
     */
    private static const VIDEOPLAYER_MUTEBUTTON:uint = 4;
    
    /**
     *  @private
     */
    private static const VIDEOPLAYER_VOLUMEBAR:uint = 5;
    
    /**
     *  @private
     */
    private static const VIDEOPLAYER_FULLSCREENBUTTON:uint = 6;

    /**
     *  @private
     */
    private static const VIDEOPLAYER_NUM_ACCESSIBLE_COMPONENTS:uint = 6;
    
	//--------------------------------------------------------------------------
	//
	//  Class methods
	//
	//--------------------------------------------------------------------------

	/**
	 *  Enables accessibility in the VideoPlayer class.
	 * 
	 *  <p>This method is called by application startup code
	 *  that is autogenerated by the MXML compiler.
	 *  Afterwards, when instances of VideoPlayer are initialized,
	 *  their <code>accessibilityImplementation</code> property
	 *  will be set to an instance of this class.</p>
	 *  
	 *  @langversion 3.0
	 *  @playerversion Flash 10
	 *  @playerversion AIR 2.0
	 *  @productversion Flex 4
	 */
	 
	public static function enableAccessibility():void
	{
		VideoPlayer.createAccessibilityImplementation =
			createAccessibilityImplementation;
	}

	/**
	 *  @private
	 *  Creates a VideoPlayer's AccessibilityImplementation object.
	 *  This method is called from UIComponent's
	 *  initializeAccessibility() method.
	 */
	mx_internal static function createAccessibilityImplementation(
								component:UIComponent):void
	{
		component.accessibilityImplementation =
			new VideoPlayerAccImpl(component);
	}

	//--------------------------------------------------------------------------
	//
	//  Constructor
	//
	//--------------------------------------------------------------------------

	/**
	 *  Constructor.
	 *
	 *  @param master The UIComponent instance that this AccImpl instance
	 *  is making accessible.
	 *  
	 *  @langversion 3.0
	 *  @playerversion Flash 10
	 *  @playerversion AIR 2.0
	 *  @productversion Flex 4
	 */
	public function VideoPlayerAccImpl(master:UIComponent)
	{
	    super(master);

	    role = AccConst.ROLE_SYSTEM_PANE; 
        
		// VideoPlayer has a playPauseButton and a volumeBar as skin parts,
		// and we need to listen to some of their events.
		// They may or may not be present when this constructor is called.
		// If they come or go later, we are notified via
		// "partAdded" and "partRemoved" events.

		var playPauseButton:ToggleButtonBase =
			VideoPlayer(master).playPauseButton;
		if (playPauseButton)
			playPauseButton.addEventListener(Event.CHANGE, eventHandler);

		var volumeBar:VolumeBar = VideoPlayer(master).volumeBar;
        if (volumeBar)
		{
			volumeBar.addEventListener(Event.CHANGE, eventHandler);
			volumeBar.addEventListener(FlexEvent.MUTED_CHANGE, eventHandler);
		}
	}

	//--------------------------------------------------------------------------
	//
	//  Overridden properties: AccImpl
	//
	//--------------------------------------------------------------------------

	//----------------------------------
	//  eventsToHandle
	//----------------------------------

	/**
	 *  @private
	 *	Array of events that we should listen for from the master component.
	 */
	override protected function get eventsToHandle():Array
	{
        return super.eventsToHandle.concat([ MouseEvent.CLICK,
        									 FocusEvent.FOCUS_IN,
											 TimeEvent.CURRENT_TIME_CHANGE,
											 SkinPartEvent.PART_ADDED,
											 SkinPartEvent.PART_REMOVED ])
	}

	//--------------------------------------------------------------------------
	//
	//  Overridden methods: AccessibilityImplementation
	//
	//--------------------------------------------------------------------------

	/**
	 *  @private
	 *  Method to return the location of the child display object
 	 *  This function should never be called for parent (childID 0)
	 *
	 *  @return any
	 */
	override public function accLocation(childID:uint):*
	{
	    var videoPlayer:VideoPlayer = VideoPlayer(master);
		
	    switch (childID)
        {
            case VIDEOPLAYER_PLAYPAUSEBUTTON:
            {
                return videoPlayer.playPauseButton;
            }
				
            case VIDEOPLAYER_SCRUBBAR: 
            {
                return videoPlayer.scrubBar;
            }
				
            case VIDEOPLAYER_CURRENTTIMEDISPLAY:
            {
                return videoPlayer.currentTimeDisplay;
            }
				
            case VIDEOPLAYER_MUTEBUTTON:
            {
                return videoPlayer.volumeBar;
            }
				
            case VIDEOPLAYER_VOLUMEBAR:
            {
                return videoPlayer.volumeBar.dropDown;
            }
				
            case VIDEOPLAYER_FULLSCREENBUTTON:
            {
                return videoPlayer.fullScreenButton;
            }
        } 
	}
	
	/**
	 *  @private
	 *  Method to return an array of childIDs.
	 *  Currently there are six (6) child objects that render accessibility
     *
	 *  @return Array
	 */
	override public function getChildIDArray():Array
	{
        return createChildIDArray(VIDEOPLAYER_NUM_ACCESSIBLE_COMPONENTS); 
	}
	
	/**
	 *  @private
	 *  IAccessible method for returning the role of the VideoPlayer components.
	 *  Roles are predefined for all the components in MSAA.
	 *  Roles are assigned to each component.
	 *  Depending upon the video player's focused control
	 *
	 *  @param childID uint
	 *
	 *  @return Role uint
	 */
	override public function get_accRole(childID:uint):uint
	{
	    var accRole:uint;

		switch (childID) 
        {
		    case 0:
            {
		        accRole = role; // PANE
		        break;
		    }
				
		    case VIDEOPLAYER_PLAYPAUSEBUTTON:
            {
			    accRole = AccConst.ROLE_SYSTEM_PUSHBUTTON;  // playPauseButton
			    break;
    		}
				
    		case VIDEOPLAYER_SCRUBBAR:
            {
			    accRole = AccConst.ROLE_SYSTEM_SLIDER;  // scrubBar
			    break;
		    }
				
		    case VIDEOPLAYER_CURRENTTIMEDISPLAY:
            {
			    accRole = AccConst.ROLE_SYSTEM_STATICTEXT; // currentTime
			    break;
       		}
				
    		case VIDEOPLAYER_MUTEBUTTON:
            {
			    accRole = AccConst.ROLE_SYSTEM_PUSHBUTTON;  // volumeBar
			    break;
		    }
				
		    case VIDEOPLAYER_VOLUMEBAR:
            {
			    accRole = AccConst.ROLE_SYSTEM_SLIDER;  // volumeBar
			    break;
		    }
				
		    case VIDEOPLAYER_FULLSCREENBUTTON:
            {
			    accRole = AccConst.ROLE_SYSTEM_PUSHBUTTON; // fullScreenButton
			    break;
		    }
		}
        
		return accRole;
	}
	
	/**
	 *  @private
	 *  IAccessible method for returning the state of the VideoPlayer.
	 *  States are predefined for all the components in MSAA.
	 *  Values are assigned to each state.
	 *  Depending upon the video player controls being pressed or released,
	 *  a value is returned.
	 *
	 *  @param childID uint
	 *
	 *  @return State uint
	 */
	override public function get_accState(childID:uint):uint
	{
	    var accState:uint;
	    var index:uint = get_accFocus();
	    var videoPlayer:VideoPlayer = VideoPlayer(master);

        // pull from the default accessibility implementation
	    accState |= getState(childID);  
	
        if (!videoPlayer.enabled)
        {
            accState |= AccConst.STATE_SYSTEM_UNAVAILABLE;
            return accState;
        }

        if (childID == VIDEOPLAYER_VOLUMEBAR && 
        	!videoPlayer.volumeBar.isDropDownOpen)
        {
            accState |= AccConst.STATE_SYSTEM_UNAVAILABLE;
            return accState;
        }

        if ((childID == VIDEOPLAYER_PLAYPAUSEBUTTON && 
        	 !videoPlayer.playPauseButton.enabled) ||
           (childID == VIDEOPLAYER_SCRUBBAR && 
        	!videoPlayer.scrubBar.enabled) ||
           (childID == VIDEOPLAYER_CURRENTTIMEDISPLAY && 
        	!videoPlayer.currentTimeDisplay.enabled) ||
           (childID == VIDEOPLAYER_MUTEBUTTON && 
        	!videoPlayer.volumeBar.enabled) ||
           (childID == VIDEOPLAYER_VOLUMEBAR && 
        	!videoPlayer.volumeBar.enabled) ||
           (childID == VIDEOPLAYER_FULLSCREENBUTTON &&
        	!videoPlayer.fullScreenButton.enabled))
        {
           accState |= AccConst.STATE_SYSTEM_UNAVAILABLE;
           return accState;
        }

        // eveything except for the currentTimeDisplay should be focusable
        if (childID != VIDEOPLAYER_CURRENTTIMEDISPLAY) 
            accState |=	AccConst.STATE_SYSTEM_FOCUSABLE;

        if (childID == index)
            accState |= AccConst.STATE_SYSTEM_FOCUSED;

        // invisible for slider when not visible
        return accState;
	}

	/**
	 *  @private
	 *  IAccessible method for returning the default action
	 *  of the VideoPlayer, which is Press.
	 *
	 *  @param childID uint
	 *
	 *  @return DefaultAction String
	 */
	override public function get_accDefaultAction(childID:uint):String
	{
		var action:String = "";
		
		switch (childID)
        {
		    case VIDEOPLAYER_PLAYPAUSEBUTTON: 
            {
                action = "Toggle";
                break;
            }
            
			case VIDEOPLAYER_MUTEBUTTON:
            case VIDEOPLAYER_FULLSCREENBUTTON:
            {
		        action = "Press";
		        break;
		    }
		}

		return action;
	}

	/**
	 *  @private
	 *  IAccessible method for returning the childFocus of the VideoPlayer.
	 *
	 *  @param childID uint
	 *
	 *  @return focused childID
	 */
	override public function get_accFocus():uint
	{
		var videoPlayer:VideoPlayer = VideoPlayer(master);
	
		var index:Number = 0;
		
		index = elementToChildID(videoPlayer.getFocus());

		return index;
	}

	/**
	 *  @private
	 *  IAccessible method for performing the default action
	 *  associated with VideoPlayer, which is Press.
	 *
	 *  @param childID uint
	 */
	override public function accDoDefaultAction(childID:uint):void
	{
		var videoPlayer:VideoPlayer = VideoPlayer(master);
		
		var clickEvent:MouseEvent; 		
	                
		if (master.enabled)
		{
			if (childID == VIDEOPLAYER_PLAYPAUSEBUTTON)
			{
				clickEvent = new MouseEvent(MouseEvent.CLICK);
				videoPlayer.playPauseButton.dispatchEvent(clickEvent);
			}
			
			else if (childID == VIDEOPLAYER_MUTEBUTTON)
            {
				videoPlayer.volumeBar.muted = !videoPlayer.volumeBar.muted;
				
				var mutedChangeEvent:FlexEvent =
					new FlexEvent(FlexEvent.MUTED_CHANGE);	
				videoPlayer.volumeBar.dispatchEvent(mutedChangeEvent);
			}
			
			else if (childID == VIDEOPLAYER_FULLSCREENBUTTON)
			{
				clickEvent = new MouseEvent(MouseEvent.CLICK);
				videoPlayer.fullScreenButton.dispatchEvent(clickEvent);
			}
		}
	}
	
	/**
	 *  @private
	 *  IAccessible method for returning the value of sliders
	 *  which is spoken out by the screen reader
	 *  @param childID uint
	 *
	 *  @return Value String
	 */
	override public function get_accValue(childID:uint):String
	{
		var videoPlayer:VideoPlayer = VideoPlayer(master);
		
		var accValue:String = "";
		
		if (childID == VIDEOPLAYER_SCRUBBAR) 
  	   	    accValue = videoPlayer.currentTimeDisplay.text; 
		
		else if (childID == VIDEOPLAYER_VOLUMEBAR) 
            accValue = String(Math.floor(videoPlayer.volumeBar.value * 100));
		
		return accValue;
	}

    /**
     *  @private
     *  IAccessible method for setting focus or selecting a child element
     *  @param selFlag uint
     *  @param childID uint
	 */
	override public function accSelect(selFlag:uint, childID:uint):void
	{   
        var videoPlayer:VideoPlayer = VideoPlayer(master);

	    if (selFlag == AccConst.SELFLAG_TAKEFOCUS) 
        {
	       	switch (childID) 
            {
	            case VIDEOPLAYER_PLAYPAUSEBUTTON: 
                {
			        videoPlayer.playPauseButton.setFocus();
			 	    break;
			    }
					
			    case VIDEOPLAYER_SCRUBBAR:
                {
			     	videoPlayer.scrubBar.setFocus();
			     	break;
			    }
					
			    case VIDEOPLAYER_MUTEBUTTON:
                {
			     	 videoPlayer.volumeBar.setFocus();
			     	 break;
			    }
					
			    case VIDEOPLAYER_VOLUMEBAR:
                {
			    	 videoPlayer.volumeBar.setFocus();
			    	 break;
			    }
					
			    case VIDEOPLAYER_FULLSCREENBUTTON:
                {
			    	 videoPlayer.fullScreenButton.setFocus();
			         break;
			    }
		    } 
	    }
	}

	//--------------------------------------------------------------------------
	//
	//  Overridden methods: AccImpl
	//
	//--------------------------------------------------------------------------

	/**
	 *  @private
	 *  method for returning the name of the VideoPlayer
	 *  which is spoken out by the screen reader
	 *  The VideoPlayer parent object will return the accessible name set on the 
     *  VideoPlayer or if one does not exist the one set in the resource file
	 *  Child elements will use the accessible name that is set on those child 
     *  components in the VideoPlayerSkin.mxml or associated skin file if they 
     *  exist otherwise the name will be retrieved from the resource file
	 *  
	 *  @param childID uint
	 *
	 *  @return Name String
	 */
	override protected function getName(childID:uint):String
	{
		var videoPlayer:VideoPlayer = VideoPlayer(master);
		
		var resourceManager:IResourceManager = ResourceManager.getInstance();

		var label:String;
        var name1:String = "";
        var name2:String = "";

		switch (childID)
        {
		    case 0: 
            {
                label = videoPlayer.accessibilityName ?
						videoPlayer.accessibilityName : 
                		resourceManager.getString(
							"components", "videoPlayerVideoDisplayAccName");
		    	break;
		    }
				
		    case VIDEOPLAYER_PLAYPAUSEBUTTON:
            {
                label = videoPlayer.playPauseButton.accessibilityProperties ?
						videoPlayer.playPauseButton.accessibilityName :
						"";
                if (!label)
                {
                    label = resourceManager.getString(
						"components", "videoPlayerPlayButtonAccName")
                }
                
                if (label.indexOf(",") >= 0) 
                {
                    name1 = label.split(",",2)[0];
                    name2 = label.split(",",2)[1] 
                }
                else 
                {
                   name1 = name2 = label;
                }

		        label = videoPlayer.playing ? name2 : name1;
                
		    	break;
		    }
		    case VIDEOPLAYER_SCRUBBAR:
            {
                label = videoPlayer.scrubBar.accessibilityName ?
						videoPlayer.scrubBar.accessibilityName : 
                		resourceManager.getString(
							"components","videoPlayerScrubBarAccName")
                break;
	        }
				
		    case VIDEOPLAYER_CURRENTTIMEDISPLAY:
            {
		        label = videoPlayer.currentTimeDisplay.text + "/" +
                		videoPlayer.durationDisplay.text;
		        break;
		    }
				
            case VIDEOPLAYER_MUTEBUTTON:
            {
                label =
					videoPlayer.volumeBar.muteButton.accessibilityProperties ?
					videoPlayer.volumeBar.muteButton.accessibilityName :
					"";
                if (!label)
                {
                    label = resourceManager.getString(
						"components", "videoPlayerMuteButtonAccName")
                }
                
                if (label.indexOf(",") >= 0) 
                {
                    name1 = label.split(",",2)[0];
                    name2 = label.split(",",2)[1] 
                }
                else 
                {
                   name1 = name2 = label;
                }

                label = videoPlayer.volumeBar.muted ? name2 : name1;
                
                break;
            }
				
            case VIDEOPLAYER_VOLUMEBAR:
            {
                label = videoPlayer.volumeBar.accessibilityName ?
						videoPlayer.volumeBar.accessibilityName : 
                		resourceManager.getString(
							"components", "videoPlayerVolumeBarAccName")
                break;
            }
				
            case VIDEOPLAYER_FULLSCREENBUTTON:
            {
                label = videoPlayer.fullScreenButton.accessibilityName ?
						videoPlayer.fullScreenButton.accessibilityName : 
                		resourceManager.getString(
							"components", "videoPlayerFullScreenButtonAccName")
                break;
            }
		}
        
		return label;
	}

	//--------------------------------------------------------------------------
	//
	//  Methods
	//
	//--------------------------------------------------------------------------

    /**
     *  @private
     *  Returns a child id based on a sub component that is passed in. 
     */
	private function elementToChildID(obj:Object):Number 
	{
		var index:Number = 0;

		var str:String = String(obj);
		
        if (str.search("playPauseButton") > 0) 
            index = VIDEOPLAYER_PLAYPAUSEBUTTON;
		
        else if (str.search("scrubBar") > 0)
            index = VIDEOPLAYER_SCRUBBAR;
		
        else if (str.search("durationDisplay") > 0) 
            index = VIDEOPLAYER_CURRENTTIMEDISPLAY;
		
        else if (str.search("volumeBar") > 0)
            index = VIDEOPLAYER_VOLUMEBAR;
		
        else if (str.search("fullScreenButton") > 0)
            index = VIDEOPLAYER_FULLSCREENBUTTON;
          
		return index;
		
	}
	
	//--------------------------------------------------------------------------
	//
	//  Overridden event handlers: AccImpl
	//
	//--------------------------------------------------------------------------

	/**
	 *  @private
	 *  Override the generic event handler.
	 *  All AccImpl must implement this
	 *  to listen for events from its master component. 
	 */
	override protected function eventHandler(event:Event):void
	{
		// Let AccImpl class handle the events
		// that all accessible UIComponents understand.
		$eventHandler(event);
		
		var childID:Number = elementToChildID(event.target);
		
		var playPauseButton:ToggleButtonBase;
		var volumeBar:VolumeBar;
		
		switch (event.type)
		{
			case MouseEvent.CLICK:
			{
				Accessibility.sendEvent(master, 0,
										AccConst.EVENT_OBJECT_STATECHANGE);
				Accessibility.updateProperties();
				break;
			}
				
			case FocusEvent.FOCUS_IN:
			{
				Accessibility.sendEvent(master, get_accFocus(), 
                						AccConst.EVENT_OBJECT_FOCUS);
				Accessibility.updateProperties();
				break;
			}
				
			case Event.CHANGE:
			{
				var msaaEvt:uint = 0;

				if (childID == VIDEOPLAYER_PLAYPAUSEBUTTON ||
					childID == VIDEOPLAYER_MUTEBUTTON || 
                	childID == VIDEOPLAYER_FULLSCREENBUTTON)
				{
					msaaEvt = AccConst.EVENT_OBJECT_NAMECHANGE;
				}
				else if (childID == VIDEOPLAYER_SCRUBBAR ||
						 childID == VIDEOPLAYER_VOLUMEBAR)
				{
					msaaEvt = AccConst.EVENT_OBJECT_VALUECHANGE;
				}
                if (childID != VIDEOPLAYER_CURRENTTIMEDISPLAY && childID != 0)
                {
				    Accessibility.sendEvent(master, childID, msaaEvt);
				    Accessibility.updateProperties();
				    break;
                }
			}
				
			case FlexEvent.MUTED_CHANGE:
			{
				Accessibility.sendEvent(master, VIDEOPLAYER_MUTEBUTTON, 
                						AccConst.EVENT_OBJECT_NAMECHANGE);
				Accessibility.updateProperties();
				break;
			}
				
            case TimeEvent.CURRENT_TIME_CHANGE:
			{
				Accessibility.sendEvent(master, VIDEOPLAYER_SCRUBBAR, 
                						AccConst.EVENT_OBJECT_VALUECHANGE);
				Accessibility.sendEvent(master, VIDEOPLAYER_CURRENTTIMEDISPLAY, 
                						AccConst.EVENT_OBJECT_NAMECHANGE);
				Accessibility.updateProperties();
				break;
			}
				
			case SkinPartEvent.PART_ADDED:
			{
				playPauseButton = VideoPlayer(master).playPauseButton;
				if (SkinPartEvent(event).instance == playPauseButton)
					playPauseButton.addEventListener(Event.CHANGE, eventHandler);
				
				volumeBar = VideoPlayer(master).volumeBar;
				if (SkinPartEvent(event).instance == volumeBar)
				{
					volumeBar.addEventListener(Event.CHANGE, eventHandler);
					volumeBar.addEventListener(FlexEvent.MUTED_CHANGE, eventHandler);
				}

				break;
			}
				
			case SkinPartEvent.PART_REMOVED:
			{
				playPauseButton = VideoPlayer(master).playPauseButton;
				if (SkinPartEvent(event).instance == playPauseButton)
					playPauseButton.removeEventListener(Event.CHANGE, eventHandler);
				
				volumeBar = VideoPlayer(master).volumeBar;
				if (SkinPartEvent(event).instance == volumeBar)
				{
					volumeBar.removeEventListener(Event.CHANGE, eventHandler);
					volumeBar.removeEventListener(FlexEvent.MUTED_CHANGE, eventHandler);
				}
				
				break;
			}
		}
	}
}

}
