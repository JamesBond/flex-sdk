////////////////////////////////////////////////////////////////////////////////
//
//  ADOBE SYSTEMS INCORPORATED
//  Copyright 2010 Adobe Systems Incorporated
//  All Rights Reserved.
//
//  NOTICE: Adobe permits you to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
//
////////////////////////////////////////////////////////////////////////////////

package spark.accessibility
{

import flash.accessibility.Accessibility;
import flash.events.Event;
import mx.accessibility.AccConst;
import mx.collections.IList;
import mx.core.UIComponent;
import mx.core.mx_internal;
import mx.resources.ResourceManager;
import mx.resources.IResourceManager;
import spark.components.DataGrid;
import spark.components.Grid;  
import spark.components.supportClasses.GridSelectionMode;
import spark.components.supportClasses.CellPosition;
import spark.events.GridEvent;
import spark.events.GridCaretEvent;
import spark.events.GridSelectionEvent;
import spark.skins.spark.DefaultGridItemRenderer;

use namespace mx_internal;

/**
 *  DataGridAccImpl is a subclass of AccessibilityImplementation
 *  which implements accessibility for the DataGrid class.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 */
public class DataGridAccImpl extends ListBaseAccImpl
{
    include "../core/Version.as";

    private var focusedCell:CellPosition = new CellPosition();
	// See the DataGridAccImpl constructor for why this is not initialized here.
	private static var dgAccInfo:ItemAccInfo; // = new ItemAccInfo();

	//--------------------------------------------------------------------------
	//
	//  Class methods
	//
	//--------------------------------------------------------------------------

	/**
	 *  Enables accessibility in the DataGrid class.
	 * 
	 *  <p>This method is called by application startup code
	 *  that is autogenerated by the MXML compiler.
	 *  Afterwards, when instances of DataGrid are initialized,
	 *  their <code>accessibilityImplementation</code> property
	 *  will be set to an instance of this class.</p>
	 *  
	 *  @langversion 3.0
	 *  @playerversion Flash 10
	 *  @playerversion AIR 1.5
	 *  @productversion Flex 4
	 */
	public static function enableAccessibility():void
	{
		DataGrid.createAccessibilityImplementation =
			createAccessibilityImplementation;
	}

	/**
	 *  @private
	 *  Creates a DataGrid's AccessibilityImplementation object.
	 *  This method is called from UIComponent's
	 *  initializeAccessibility() method.
	 */
	mx_internal static function createAccessibilityImplementation(
								component:UIComponent):void
	{
		component.accessibilityImplementation =
			new DataGridAccImpl(component);
	}

	//--------------------------------------------------------------------------
	//
	//  Constructor
	//
	//--------------------------------------------------------------------------

	/**
	 *  Constructor.
	 *
	 *  @param master The UIComponent instance that this AccImpl instance
	 *  is making accessible.
	 *  
	 *  @langversion 3.0
	 *  @playerversion Flash 10
	 *  @playerversion AIR 1.5
	 *  @productversion Flex 4
	 */
	public function DataGridAccImpl(master:UIComponent)
	{
		super(master);
		// Normally this would not be done here, but at this writing,
		// initializing dgAccInfo from its declaration line causes an RTE,
		// apparently because the AS compiler does not yet detect a forward-ref
		// problem that results in an incorrect initialization at run time.
		// [DGL, 2010-09-07]
		if (!dgAccInfo)
			dgAccInfo = new ItemAccInfo();
	}

	//--------------------------------------------------------------------------
	//
	//  Overridden properties: AccImpl
	//
	//--------------------------------------------------------------------------

	//----------------------------------
	//  eventsToHandle
	//----------------------------------

	/**
	 *  @private
	 *	Array of events that we should listen for from the master component.
	 */
	override protected function get eventsToHandle():Array
	{
        return super.eventsToHandle.concat([GridSelectionEvent.SELECTION_CHANGING]);
	}
	
	//--------------------------------------------------------------------------
	//
	//  Overridden methods: AccessibilityImplementation
	//
	//--------------------------------------------------------------------------

	/**
	 *  @private
	 *  Gets the role for the component.
	 *
	 *  @param childID Children of the component
	 */
	override public function get_accRole(childID:uint):uint
	{
		if (childID == 0)
			// Get this out of the way quick; it's often requested by AT.
			return role;
		var dataGrid:DataGrid = DataGrid(master);
        if (!dataGrid.columns)
            return null;

		if (childID <= dataGrid.columns.length && dataGrid.columnHeaderBar)
			return AccConst.ROLE_SYSTEM_COLUMNHEADER;
		else
			// Same role for all childIDs regardless of mode (row or cell).
			// Valid and invalid childIDs return this;
			// this behavior is common to most list-based controls we've seen.
			// [DGL, 2010-08-10]
			return AccConst.ROLE_SYSTEM_LISTITEM;
	}

	/**
	 *  @private
	 *  IAccessible method for returning the state of the GridItem.
	 *  States are predefined for all the components in MSAA.
	 *  Values are assigned to each state.
	 *  Depending upon the GridItem being Selected, Selectable, Invisible,
	 *  Offscreen, a value is returned.
	 *
	 *  @param childID uint
	 *
	 *  @return State uint
	 */
	override public function get_accState(childID:uint):uint
	{
		var accState:uint = getState(childID);
		if (childID <= 0)
			return accState;

		dgAccInfo.setup(master, childID);
        if (!dgAccInfo.dataGrid.columns)
            return null;
		if (dgAccInfo.isInvalid)
			// Child ID out of bounds most likely.
			return accState;
		if (dgAccInfo.isColumnHeader)
			// There are some states we don't allow for these.
			return accState & ~(
				AccConst.STATE_SYSTEM_FOCUSABLE
				| AccConst.STATE_SYSTEM_SELECTABLE
				| AccConst.STATE_SYSTEM_FOCUSED
				| AccConst.STATE_SYSTEM_SELECTED
			);

		// We now have only rows and data cells to consider.

		// Determine if this item is focused.
		if (childID == get_accFocus())	
			accState |= AccConst.STATE_SYSTEM_FOCUSED;

		// Anything (row or cell) is selectable unless selection is not allowed at all.
		if (dgAccInfo.dataGrid.selectionMode != GridSelectionMode.NONE)
			accState |= AccConst.STATE_SYSTEM_SELECTABLE;

		// Figure out visibility and selectedness.

		if (dgAccInfo.isCellMode)
		{
			var renderer:DefaultGridItemRenderer = DefaultGridItemRenderer(
				dgAccInfo.dataGrid.grid.getItemRendererAt(dgAccInfo.rowIndex, dgAccInfo.columnIndex)
			);
			if (renderer && renderer.selected)
				accState |= AccConst.STATE_SYSTEM_SELECTED;
		}
		else  // row mode
		{
			var items:Vector.<int> = dgAccInfo.dataGrid.selectedIndices;
			if (items.indexOf(dgAccInfo.rowIndex) >= 0)
				accState |= AccConst.STATE_SYSTEM_SELECTED;
		}  // cell or row mode

		return accState;
	}

	/**
	 *  @private
	 *  IAccessible method for executing the Default Action.
	 *
	 *  @param childID uint
	 */
	override public function accDoDefaultAction(childID:uint):void
	{
		dgAccInfo.setup(master, childID);
		if (!dgAccInfo.dataGrid.columns || dgAccInfo.isInvalid)
			return;

		if (dgAccInfo.isColumnHeader)
		{
        	// TODO: Allow doDefaultAction to sort columns
			return;
		}

		if (dgAccInfo.isCellMode)
		{
        	// TODO: Allow doDefaultAction to go into edit mode if editable
            var cp:CellPosition = new CellPosition();
            cp.columnIndex = dgAccInfo.columnIndex;
            cp.rowIndex = dgAccInfo.rowIndex;
            dgAccInfo.dataGrid.selectedCell = cp;
			return;
		}
		else
		{
    		dgAccInfo.dataGrid.selectedIndex = dgAccInfo.itemIndex;
			return;
		}
	}

	/**
	 *  @private
	 *  Method to return an array of childIDs.
	 *
	 *  @return Array
	 */
	override public function getChildIDArray():Array
	{
		dgAccInfo.setup(master, 0);
        if (!dgAccInfo.dataGrid.columns)
            return null;
		return createChildIDArray(dgAccInfo.maxChildID);
	}

	/**
	 *  @private
	 *  IAccessible method for returning the bounding box of the GridItem.
	 *
	 *  @param childID uint
	 *
	 *  @return Location Object
	 */
	override public function accLocation(childID:uint):*
	{
		dgAccInfo.setup(master, childID);
        if (!dgAccInfo.dataGrid.columns)
            return null;
        //var addHeader:int = dgAccInfo.dataGrid.columnHeaderBar.visible ? 1 : 0;
		var row:int = dgAccInfo.rowIndex;
		
        //row = index + addHeader;

        //TODO: Fix location if off-screen, may be ok to actually expose location
        //according to docs
        /*if (row < dgAccInfo.dataGrid.scroller.viewport.verticalScrollPosition ||
            row >= dgAccInfo.dataGrid.scroller.viewport.verticalScrollPosition + dgAccInfo.rowCount)
        {
            return null;
        } */
        
        if (dgAccInfo.isInvalid)
            return null;
        
        if (dgAccInfo.isColumnHeader)
            return dgAccInfo.dataGrid.columnHeaderBar.dataGroup.getElementAt(childID-1);
            
        // TODO: return correct height for rows and cells as incorrect height 
        // is being returned
        var renderer:Object;
        renderer = dgAccInfo.dataGrid.grid.getItemRendererAt(dgAccInfo.rowIndex, dgAccInfo.columnIndex);
        return renderer ? renderer : null;
	}

	/**
	 *  @private
	 *  IAccessible method for returning the childFocus of the DataGrid.
	 *
	 *  @param childID uint
	 *
	 *  @return focused childID.
	 */
	override public function get_accFocus():uint
	{
		dgAccInfo.setup(master, 0);
        if (!dgAccInfo.dataGrid.columns || !dgAccInfo.dataGrid.dataProvider)
            return null;

        // TODO: handle editable    
    	
		var index:int;
        if (dgAccInfo.isCellMode)
        {
            // TODO: consider handling case where no cell is select and only cell 
            // is focused and we don't have the focused cell because no caret 
            // change occurred.  Doesn't seem to cause an issue not to fix, 
            // returns list 0
            if (focusedCell.columnIndex && focusedCell.rowIndex)
			{
                index = focusedCell.rowIndex*dgAccInfo.columnCount+focusedCell.columnIndex;
			}
            else  // no focused cell so use selection
			{
				var selectedCell:CellPosition = dgAccInfo.dataGrid.selectedCell;
				if (!selectedCell)
					return 0;
	            index = selectedCell.rowIndex * dgAccInfo.columnCount +selectedCell.columnIndex;
			}
        }
        else
        {
            index = (dgAccInfo.dataGrid.selectedIndex != -1) ? dgAccInfo.dataGrid.selectedIndex : 0;
        }
			
		return index >= 0 ? index + 1 + dgAccInfo.headerCount : 0;
	}

	//--------------------------------------------------------------------------
	//
	//  Overridden methods: AccImpl
	//
	//--------------------------------------------------------------------------

	/**
	 *  @private
	 *  method for returning the name of the ListItem/DataGrid
	 *  which is spoken out by the screen reader
	 *  The ListItem should return the label as the name with m of n string and
	 *  DataGrid should return the name specified in the AccessibilityProperties.
	 *
	 *  @param childID uint
	 *
	 *  @return Name String
	 */
	override protected function getName(childID:uint):String
	{
		if (int(childID) <= 0)
			return null;
		dgAccInfo.setup(master, childID);
		if (dgAccInfo.isInvalid || !dgAccInfo.dataGrid.columns)
			return null;
		if (dgAccInfo.isColumnHeader)
			return dgAccInfo.dataGrid.columns.getItemAt(childID-1).headerText;

		// We now have only rows and data cells to consider.
        if (!dgAccInfo.dataGrid.dataProvider || !dgAccInfo.dataGrid.columns)
            return null;

		// String representation of row position.
		// TODO: Localize this.
		var rowString:String = "";
		if ((dgAccInfo.isCellMode && dgAccInfo.columnIndex == 0) || !dgAccInfo.isCellMode)
		{
			var resourceManager:IResourceManager = ResourceManager.getInstance();
			rowString = resourceManager.getString("components", "rowMofN");
			rowString = rowString.replace("%1", dgAccInfo.rowIndex + 1).replace("%2", dgAccInfo.rowCount);
		}

		// Construct the name to return.
		var name:String = "";
		// TODO: Should the types of these be more specific?
		var rowObject:Object = dgAccInfo.dataGrid.dataProvider.getItemAt(dgAccInfo.rowIndex);
        var columns:IList = dgAccInfo.dataGrid.columns;
		if (dgAccInfo.isCellMode)
		{
            name = columns.getItemAt(dgAccInfo.columnIndex).headerText + ": " 
            + cellName(rowObject, dgAccInfo.columnIndex);
		}
		else if (rowObject)  // row mode
		{
			for (var c:int = 0; c < dgAccInfo.columnCount; c++)
			{
                //TODO: remove header text if there is no columnHeaderBar
				if (c > 0)
					name += ",";
				name += " "
				+ columns.getItemAt(c).headerText
				+ ": "
				+ columns.getItemAt(c).itemToLabel(rowObject);
			}
		}  // cell or row mode
		if (rowString)
			name += ", " +rowString;

		return name;
	}

    /**
     *  @private
     *  IAccessible method for selecting an item.
     *
     *  @param childID uint
     */
    override public function accSelect(selFlag:uint, childID:uint):void
    {
		dgAccInfo.setup(master, childID);

        if (selFlag == AccConst.SELFLAG_TAKEFOCUS && !dgAccInfo.isColumnHeader && !dgAccInfo.isInvalid)
        {
            if (dgAccInfo.isCellMode)
            {
                var cellPosition:CellPosition = new CellPosition();
                cellPosition.columnIndex = dgAccInfo.columnIndex;
                cellPosition.rowIndex = dgAccInfo.rowIndex;
                dgAccInfo.dataGrid.selectedCell = cellPosition;
            }
            else
			{
                dgAccInfo.dataGrid.selectedIndex = dgAccInfo.rowIndex;
			}
        }
    }
    
    /**
     *  @private
     *  IAccessible method for returning the child Selections in the List.
     *
     *  @param childID uint
     *
     *  @return focused childID.
     */
    override public function get_accSelection():Array
    {
        var accSelection:Array = [];
		dgAccInfo.setup(master, 0);
        if (!dgAccInfo.dataGrid.columns)
            return null;
		var i:int
		var n:int
		var items:Object;
        
        if (dgAccInfo.isCellMode)
        {
			items = dgAccInfo.dataGrid.selectedCells;
			n = items.length;
            for (i = 0; i < n; i++)
            {
				// The selected childID is effectively the 1-based cell index.
				// This is row*colCount + columnInRow +columnHeaderCount +1.
                accSelection[i] = items[i].rowIndex * dgAccInfo.columnCount
                + items[i].columnIndex
                + dgAccInfo.headerCount + 1;
            }
        }
        else // row mode
        {
			items = dgAccInfo.dataGrid.selectedIndices;
			n = items.length;
            for (i = 0; i < n; i++)
            {
				// This time we just need rowIndex (0-based) + headerCount + 1.
                accSelection[i] = items[i] + dgAccInfo.headerCount + 1;
            }
        
        }

        return accSelection;

    }

	//--------------------------------------------------------------------------
	//
	//  Overridden event handlers: AccImpl
	//
	//--------------------------------------------------------------------------

	/**
	 *  @private
	 *  Override the generic event handler.
	 *  All AccImpl must implement this to listen
	 *  for events from its master component. 
	 */
	override protected function eventHandler(event:Event):void
	{
		// Let AccImpl class handle the events
		// that all accessible UIComponents understand.
		$eventHandler(event);

		dgAccInfo.setup(master, 0);
		if (!dgAccInfo.dataGrid.columns)
			return;

		var childID:uint;
        switch (event.type)
        {
            case GridCaretEvent.CARET_CHANGE:
            {
                var index:int;
                if (dgAccInfo.isCellMode)
                {
                    index = int(GridCaretEvent(event).newRowIndex)
                    * dgAccInfo.columnCount+int(GridCaretEvent(event).newColumnIndex);
                    focusedCell.rowIndex = GridCaretEvent(event).newRowIndex;
                    focusedCell.columnIndex = GridCaretEvent(event).newColumnIndex;
                }
                else // row mode
                {
                    focusedCell.rowIndex = GridCaretEvent(event).newRowIndex;              
                    index = focusedCell.rowIndex;
                }
                if (index >= 0)
                {
                    childID = index + 1 + dgAccInfo.headerCount;

                    Accessibility.sendEvent(dgAccInfo.dataGrid, childID,
                                            AccConst.EVENT_OBJECT_FOCUS);
                }
                break;
            }
            case GridSelectionEvent.SELECTION_CHANGING:
            {
                if (dgAccInfo.isCellMode)
                    index = GridSelectionEvent(event).selectionChange.rowIndex*dgAccInfo.columnCount + GridSelectionEvent(event).selectionChange.columnIndex;
                else
                    index = GridSelectionEvent(event).selectionChange.rowIndex;
                    
                if (index >= 0)
                {
                    childID = index + 1 + dgAccInfo.headerCount;                
                    Accessibility.sendEvent(dgAccInfo.dataGrid, childID,
                                            AccConst.EVENT_OBJECT_SELECTION);
                }
                break;
            }
        }
	}

	//--------------------------------------------------------------------------
	//
	//  Methods
	//
	//--------------------------------------------------------------------------

	/**
	 *  @private
	 */
	private function cellName(rowObject:Object, columnIndex:int):String
	{
		var item:Object = rowObject;
		if (item is String)
			return "" + item;
		var dataGrid:DataGrid = DataGrid(master);
		var columns:IList = dataGrid.columns;
        if (!columns)
			return null;
		var column:Object = columns.getItemAt(columnIndex);
		if (!column)
			return null;
		return column.itemToLabel(rowObject);
	}

    /**
     *  @private
     *  Returns true if the given row is above or below the viewable area.
     */
    private function rowIndexIsScrolledOffScreen(rowIndex: int): Boolean
	{
		var dataGrid:DataGrid = DataGrid(master);
		var vpos:int = dataGrid.scroller.viewport.verticalScrollPosition;
        if (rowIndex < vpos
		|| rowIndex >= vpos + dataGrid.dataProvider.length)
			return true;
		return false;
	}

}

}

internal class ItemAccInfo
{
	import mx.core.UIComponent;
	import spark.components.DataGrid;
	import spark.components.Grid;  
	import spark.components.supportClasses.GridSelectionMode;
	import spark.components.supportClasses.CellPosition;

	/**
	 *  Constructor.
	 */
	public function ItemAccInfo()
	{
		super();
	}

	/**
	 *
	 *  @param master The UIComponent instance that this AccImpl instance
	 *  is making accessible.
	 *  @param childID The childID of the item of interest.
	 */
	public function setup(master:UIComponent, childID:uint):void
	{
		this.master = master;
		this.childID = childID;
		dataGrid = DataGrid(master);
		if (dataGrid.columns)
			columnCount = dataGrid.columns.length;
		else
			columnCount = 0;
		if (dataGrid.dataProvider)
			rowCount = dataGrid.dataProvider.length;
		else
			rowCount = 0;
		itemIndex = childID - 1;
		if (dataGrid.columnHeaderBar)
		{
			// There are column headers, and their childIDs come first.
			itemIndex -= columnCount;
			headerCount = columnCount;
		}
		else
		{
			headerCount = 0;
		}
		var mode:String = dataGrid.selectionMode;
		isCellMode = (
			mode == GridSelectionMode.SINGLE_CELL
			|| mode == GridSelectionMode.MULTIPLE_CELLS
		);
		maxChildID = 0;
		// Account for headers.
		maxChildID += headerCount;
		// Then for cells or rows as appropriate.
        if (isCellMode)
			maxChildID += rowCount * columnCount;
        else
			maxChildID += rowCount;
		isColumnHeader = false;
		isInvalid = false;
		if (childIDOutOfBounds(childID))
		{
			isInvalid = true;
			columnIndex = -1;
			rowIndex = -1;
			itemIndex = -1;
		}
		else if (itemIndex < 0)
		{
			// This childID refers to a header, not a data row or cell.
			isColumnHeader = true;
			columnIndex = itemIndex + columnCount;
			rowIndex = -1;
			itemIndex = -1;
		}
		else if (isCellMode)
		{
			rowIndex = Math.floor(itemIndex / columnCount);
			columnIndex = itemIndex % columnCount;
		}
		else
		{
			rowIndex = itemIndex;
			// Using 0 here so, for example, getItemRendererAt() calls still work for a row.
			columnIndex = 0;
		}
	}

	public var master:UIComponent;
	public var childID:uint;
	public var dataGrid:DataGrid;
	public var columnCount:int;
	public var headerCount:int;
	public var rowCount:int;
	public var maxChildID:int;
	public var itemIndex:int;
	public var isCellMode:Boolean;
	public var isInvalid:Boolean;
	public var isColumnHeader:Boolean;
	public var columnIndex:int;
	public var rowIndex:int;

	public function childIDFromRowAndColumn(rowIndex:int, columnIndex:int):uint
	{
		var childID:int = headerCount + 1;
		if (isCellMode)
			childID += rowIndex * columnCount + columnIndex;
		else
			childID += rowIndex;
		return uint(childID);
	}

    private function childIDOutOfBounds(childID: int): Boolean
    {
		if (int(childID) <= 0)
			return true;
        if (!dataGrid.dataProvider || !dataGrid.columns)
            return true
		if (childID > maxChildID)
			return true;
		return false;
    }

}
